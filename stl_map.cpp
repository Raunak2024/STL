#include<iostream>
using namespace std;
int main(){
// map<key datatype,value datatype>var_name
// HASHING- EVERYTHING IS STORED IN THE FORM OF KEY->VALUE PAIRS
// COMPONENTS OF HASHING
// HASH VALUES
// HASH FUNCTION(K MOD M ) where M-> NO OF BUCKETS/ SIZE OF HASH TABLE
// HASH TABLE
// HASHING METHODS
// -> DIVISON METHOD
// -> MID-SQUARE METHOD
// -> FOLDING METHOD
// COLLISION-> WHEN TWO ELEMENTS(KEYS) HAVE THE SAME HASH VALUES 
// COLLISION RESOLUTION TECHNIQUES
// -> OPEN HASHING
// -> CLOSED HASHING-> LINEAR PROBING, QUADRATIC PROBING, DOUBLE HASHING
// LOAD FACTOR-> N/M (AVG ENTRIES IN ONE BUCKET), WHERE N->NO OF ELEMENTS, M->NO OF BUCKETS
// IF LOAD FACTOR LIMIT>0.75 => REHASHING (INCREASING SIZE OF HASH TABLE AND REDISTRIBUTING ELEMENTS IN IT)
// HASHMAPS CANNOT CONTAIN DUPLICATE ELEMENTS AS KEYS BUT CAN CONTAIN DUPLICATE HASH VALUES
// IMP- HASHING CAN BE IMPLEMENTED BY BOTH MAP(ORDERED) AND UNORDERED MAP. But, we generally use unordered map for most cases.
// ALSO UNORDERED MAP IS IMPLEMENTED BY HASH TABLES WHEREAS MAP IS IMPLEMENTED BY BST
// One way of inserting values into HASHMAP/HASHTABLE
// MAP-SORTED ORDER(DEFAULT-ASCENDING), UNORDERED MAP-RANDOM ORDER
    map<int,string>m;
    m[1]="RAUNAK NAG";
    m[2]="HULK";
    m[3]="FLASH";
    m[4]="SPEEDSTER";
    // Second way of inserting values into HASHMAP/HASHTABLE
    m.insert({5,"HULK"}); // INSERT HULK AT 5TH INDEX
    // We implement for-each loop with auto keyword
    for(auto i:m){
        cout<<i.first<<"->"<<i.second<<endl;
    }
        cout<<m.count(3)<<endl;//Returns 0 or 1 depending upon the element is found at some index or not
        m.erase{"Key-2"};// WE CAN DELETE ANY VALUE FROM THE HASHMAP THROUGH ITS INDEX 

}
